name: 'Build, Scan and Sign image using Grype and Cosign'
description: >
  Build, scan (SBOM + image via Grype), and sign (Cosign) container images.
  Generates an SBOM, scans for vulnerabilities, and optionally signs and pushes
  the image. Supports multi-platform builds, S3-hosted Grype ignore files,
  OIDC keyless signing, and GitHub Dependency Graph integration.
  See the README for usage examples and full documentation.

branding:
  icon: layers
  color: purple
inputs:
  image-repo:
    description: "The repo to push the image to. This should just be the base url, eg: my-repo or ghcr.io or, if using DockerHub, just the username you'd usually use for your repo."
    required: true
  repo-username:
    description: "The username to log into the repo."
    required: false
    default: ""
  repo-password:
    description: "The password to log into the repo."
    required: false
    default: ""
  image-name:
    description: "The name of the image to build."
    required: true
  image-tag:
    description: "The tag to build the image with - provide a matrix to build against multiple tags as each will need to be SBOM'd, scanned and signed independently."
    required: true
  add-latest-tag:
    description: "Adds the latest tag to the build."
    required: false
    default: "false"
  build-args:
    description: "Add additional build args via the --build-arg flag. this should be a comma separated list like 'SOME_KEY=SOME_VALUE,ANOTHER_KEY=ANOTHER_VALUE'"
    required: false
    default: ""
  cosign-private-key:
    description: "A private key with which to sign the image using cosign. Required when signing-mode is 'private-key'."
    required: false
    default: ""
  cosign-password:
    description: "The password to unlock the private key. Required when signing-mode is 'private-key'."
    required: false
    default: ""
  cosign-tlog:
    description: "Set to true to upload to tlog for transparency."
    required: false
    default: 'false'
  signing-mode:
    description: "Signing mode: 'private-key' (requires cosign-private-key and cosign-password) or 'oidc' (keyless, requires id-token: write permission)."
    required: false
    default: "private-key"
  publish-image:
    description: "If true the image will be published to the repo."
    default: 'false'
    required: false
  check-severity:
    description: "A comma delimited (uppercase) list of severities to check for. If found the pipeline will fail. Support values: UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL"
    required: false
    default: HIGH
  severity-fail-on-detection:
    description: "Whether or not to fail the build should a 'check-severity' level vulnerability be found."
    required: false
    default: 'true'
  grypeignore-file:
    description: "Supply a Grype ignore file to ignore specific CVEs and prevent a pipeline failure."
    required: false
    default: ".grype.yaml"
  grypeignore-from-s3:
    description: "If disabled, the Grype ignore can be supplied via the repo itself but actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 must be used before calling this action."
    required: false
    default: "false"
  ignore-not-fixed:
    description: "If true, CVEs that do not have a fixed version will be ignored"
    default: "false"
  enable-dependency-graph:
    description: "Will upload the SBOM to GitHub Dependency Graph - you must enable this and enable write permissions on your workflow for this to work."
    required: false
    default: "false"
  github-token:
    description: "This can be a PAT or the GITHUB_TOKEN secret. Required when enable-dependency-graph is true."
    required: false
    default: ""
  s3-endpoint:
    description: "If the endpoint isn't a standard AWS one, pass it in here."
    required: false
    default: ""
  s3-region:
    description: "The AWS Region."
    required: false
    default: "us-east-1"
  s3-access-key:
    description: "The S3 access key."
    required: false
    default: ""
  s3-secret-key:
    description: "The S3 secret key."
    required: false
    default: ""
  s3-bucket:
    description: "The S3 bucket in which the grype ignore file is stored."
    required: false
    default: "grypeignores"
  s3-path:
    description: "The path in the s3 bucket to the grype ignore file."
    required: false
    default: ".grype.yaml"
  dockerfile-path:
    description: "Path to the Dockerfile (default {context}/Dockerfile)."
    required: false
    default: "."
  skip-image-scan:
    description: "If true, skip the container image scan (SBOM scan still runs). Useful for faster builds when SBOM scan provides sufficient coverage."
    required: false
    default: "false"
  platforms:
    description: "Comma-separated list of platforms for multi-platform builds (e.g. 'linux/amd64,linux/arm64'). When set, publish-image must be true as multi-platform builds push during build."
    required: false
    default: ""

outputs:
  image-digest:
    description: "SHA256 digest of the built/pushed image"
    value: ${{ steps.set-outputs.outputs.image-digest }}
  sbom-path:
    description: "Path to the generated SBOM file"
    value: ${{ steps.set-outputs.outputs.sbom-path }}
  scan-passed:
    description: "'true' if the vulnerability scan passed, 'false' otherwise"
    value: ${{ steps.set-outputs.outputs.scan-passed }}
  image-ref:
    description: "Full image reference (registry/name:tag)"
    value: ${{ steps.set-outputs.outputs.image-ref }}
  cve-list:
    description: "JSON array of CVE objects with id, severity, package, version, fixed_version"
    value: ${{ steps.parse-scan-results.outputs.cve-list }}
  cve-count:
    description: "Integer count of CVEs at or above the configured severity threshold"
    value: ${{ steps.parse-scan-results.outputs.cve-count }}
  cve-summary:
    description: "Human-readable summary of CVE findings"
    value: ${{ steps.parse-scan-results.outputs.cve-summary }}

runs:
  using: "composite"
  steps:
    - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4.3.0

    - name: Validate Inputs
      shell: bash
      env:
        INPUT_CHECK_SEVERITY: ${{ inputs.check-severity }}
        INPUT_SIGNING_MODE: ${{ inputs.signing-mode }}
        INPUT_COSIGN_PRIVATE_KEY: ${{ inputs.cosign-private-key }}
        INPUT_COSIGN_PASSWORD: ${{ inputs.cosign-password }}
        INPUT_PUBLISH_IMAGE: ${{ inputs.publish-image }}
        INPUT_REPO_USERNAME: ${{ inputs.repo-username }}
        INPUT_REPO_PASSWORD: ${{ inputs.repo-password }}
        INPUT_GRYPEIGNORE_FROM_S3: ${{ inputs.grypeignore-from-s3 }}
        INPUT_S3_ACCESS_KEY: ${{ inputs.s3-access-key }}
        INPUT_S3_SECRET_KEY: ${{ inputs.s3-secret-key }}
        INPUT_S3_BUCKET: ${{ inputs.s3-bucket }}
        INPUT_ENABLE_DEPENDENCY_GRAPH: ${{ inputs.enable-dependency-graph }}
        INPUT_GITHUB_TOKEN: ${{ inputs.github-token }}
        INPUT_PLATFORMS: ${{ inputs.platforms }}
        INPUT_DOCKERFILE_PATH: ${{ inputs.dockerfile-path }}
      run: bash "${GITHUB_ACTION_PATH}/scripts/validate-inputs.sh"

    - name: Pull From S3
      if: inputs.grypeignore-from-s3 == 'true'
      shell: bash
      env:
        AWS_ACCESS_KEY_ID: ${{ inputs.s3-access-key }}
        AWS_SECRET_ACCESS_KEY: ${{ inputs.s3-secret-key }}
        AWS_DEFAULT_REGION: ${{ inputs.s3-region }}
        INPUT_S3_ENDPOINT: ${{ inputs.s3-endpoint }}
        INPUT_S3_BUCKET: ${{ inputs.s3-bucket }}
        INPUT_S3_PATH: ${{ inputs.s3-path }}
        INPUT_GRYPEIGNORE_FILE: ${{ inputs.grypeignore-file }}
      run: |
        ENDPOINT_FLAG=""
        if [[ -n "${INPUT_S3_ENDPOINT}" ]]; then
          ENDPOINT_FLAG="--endpoint-url=${INPUT_S3_ENDPOINT}"
        fi
        if ! aws ${ENDPOINT_FLAG} s3 cp "s3://${INPUT_S3_BUCKET}/${INPUT_S3_PATH}" "${INPUT_GRYPEIGNORE_FILE}"; then
          echo "::error::Failed to pull grypeignore file from S3"
          exit 1
        fi
        if [[ "${INPUT_GRYPEIGNORE_FILE}" != ".grype.yaml" ]]; then
          cp "${INPUT_GRYPEIGNORE_FILE}" .grype.yaml
        fi

    - name: Detect Registry and Tags
      shell: bash
      env:
        INPUT_IMAGE_REPO: ${{ inputs.image-repo }}
        INPUT_IMAGE_NAME: ${{ inputs.image-name }}
        INPUT_IMAGE_TAG: ${{ inputs.image-tag }}
        INPUT_ADD_LATEST_TAG: ${{ inputs.add-latest-tag }}
        INPUT_REPO_USERNAME: ${{ inputs.repo-username }}
      run: bash "${GITHUB_ACTION_PATH}/scripts/detect-registry.sh"

    # Install cosign before build (multi-platform builds push during build and need signing after)
    - name: Install Cosign
      if: inputs.publish-image == 'true'
      uses: sigstore/cosign-installer@d58896d6a1865668819e1d91763c7751a165e159 # v3.9.2

    # Login into registry before build (multi-platform builds push during build)
    ### USING DOCKERHUB ###
    - name: Login to Docker Registry
      if: inputs.publish-image == 'true' && env.IS_DOCKERHUB == 'true'
      uses: docker/login-action@184bdaa0721073962dff0199f1fb9940f07167d1 # v3.5.0
      with:
        username: ${{ inputs.repo-username }}
        password: ${{ inputs.repo-password }}

    ### USING NON-DOCKERHUB ###
    - name: Login to Container Registry
      if: inputs.publish-image == 'true' && env.IS_DOCKERHUB == 'false'
      uses: docker/login-action@184bdaa0721073962dff0199f1fb9940f07167d1 # v3.5.0
      with:
        registry: ${{ inputs.image-repo }}
        username: ${{ inputs.repo-username }}
        password: ${{ inputs.repo-password }}

    - name: Build Docker Image
      shell: bash
      env:
        INPUT_DOCKERFILE_PATH: ${{ inputs.dockerfile-path }}
        INPUT_BUILD_ARGS: ${{ inputs.build-args }}
        INPUT_PLATFORMS: ${{ inputs.platforms }}
      run: bash "${GITHUB_ACTION_PATH}/scripts/build-image.sh"

    # Create an SBOM file for the local image and upload the results
    - name: Create SBOM (Push to Dependency Graph if enabled)
      if: env.MULTIPLATFORM_BUILD != 'true'
      uses: anchore/sbom-action@28d71544de8eaf1b958d335707167c5f783590ad # v0.22.2
      with:
        format: spdx-json
        output-file: "${{ inputs.image-name }}-sbom.spdx.json"
        image: "${{ env.IMAGE_REF }}:${{ env.VERSION_TAG }}"
        dependency-snapshot: ${{ inputs.enable-dependency-graph }}
        github-token: ${{ inputs.github-token }}

    # Create SBOM for multi-platform builds (from Dockerfile/context instead of local image)
    - name: Create SBOM from Dockerfile (Multi-platform)
      if: env.MULTIPLATFORM_BUILD == 'true'
      uses: anchore/sbom-action@28d71544de8eaf1b958d335707167c5f783590ad # v0.22.2
      with:
        format: spdx-json
        output-file: "${{ inputs.image-name }}-sbom.spdx.json"
        path: "${{ inputs.dockerfile-path }}"
        dependency-snapshot: ${{ inputs.enable-dependency-graph }}
        github-token: ${{ inputs.github-token }}

    # Scan the SBOM
    - name: Scan SBOM
      uses: anchore/scan-action@568b89d27fc18c60e56937bff480c91c772cd993 # v7.1.0
      id: scan-sbom
      with:
        sbom: "${{ inputs.image-name }}-sbom.spdx.json"
        fail-build: ${{ inputs.severity-fail-on-detection }}
        severity-cutoff: ${{ inputs.check-severity }}
        cache-db: true
        output-format: json
        only-fixed: ${{ inputs.ignore-not-fixed }}

    # Upload the SBOM scan results regardless of scan pass or failure
    - name: Upload SBOM Scan Results
      uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
      if: (success() || failure()) && (steps.scan-sbom.conclusion == 'success' || steps.scan-sbom.outcome == 'failure')
      with:
        name: "${{ inputs.image-name }}-sbom-results.json"
        path: "${{ steps.scan-sbom.outputs.json }}"

    # Scan the local image (only for single-platform builds, skippable)
    - name: Scan image
      id: image-scan
      if: env.MULTIPLATFORM_BUILD != 'true' && inputs.skip-image-scan != 'true'
      uses: anchore/scan-action@568b89d27fc18c60e56937bff480c91c772cd993 # v7.1.0
      with:
        image: "${{ env.IMAGE_REF }}:${{ env.VERSION_TAG }}"
        output-format: 'json'
        fail-build: ${{ inputs.severity-fail-on-detection }}
        severity-cutoff: ${{ inputs.check-severity }}
        cache-db: true
        only-fixed: ${{ inputs.ignore-not-fixed }}

    # Upload the image scan results regardless of scan pass or failure
    - name: Upload Container Scan Results
      uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
      if: env.MULTIPLATFORM_BUILD != 'true' && inputs.skip-image-scan != 'true' && (success() || failure()) && (steps.image-scan.conclusion == 'success' || steps.image-scan.outcome == 'failure')
      with:
        name: "${{ inputs.image-name }}-scan-results.json"
        path: "${{ steps.image-scan.outputs.json }}"

    # Parse scan results to extract CVE data
    - name: Parse Scan Results
      id: parse-scan-results
      if: always()
      shell: bash
      env:
        INPUT_CHECK_SEVERITY: ${{ inputs.check-severity }}
        SBOM_SCAN_RESULTS: ${{ steps.scan-sbom.outputs.json }}
        IMAGE_SCAN_RESULTS: ${{ steps.image-scan.outputs.json }}
      run: bash "${GITHUB_ACTION_PATH}/scripts/parse-scan-results.sh"

    # Push Docker Image (only for single-platform builds; multi-platform already pushed during build)
    - name: Push Docker Image
      if: inputs.publish-image == 'true' && env.MULTIPLATFORM_BUILD != 'true'
      shell: bash
      run: |
        for tag in ${TAGS}; do
          docker push "${IMAGE_REF}:${tag}"
        done

    - name: Sign Image
      if: inputs.publish-image == 'true'
      shell: bash
      env:
        INPUT_SIGNING_MODE: ${{ inputs.signing-mode }}
        INPUT_COSIGN_TLOG: ${{ inputs.cosign-tlog }}
        COSIGN_PRIVATE_KEY: ${{ inputs.cosign-private-key }}
        COSIGN_PASSWORD: ${{ inputs.cosign-password }}
      run: bash "${GITHUB_ACTION_PATH}/scripts/sign-image.sh"

    - name: Set Outputs
      id: set-outputs
      if: always()
      shell: bash
      run: |
        # Image digest - prefer FINAL_IMAGE_DIGEST (from signing), fall back to IMAGE_DIGEST (from build)
        DIGEST="${FINAL_IMAGE_DIGEST:-${IMAGE_DIGEST:-}}"
        echo "image-digest=${DIGEST}" >> "${GITHUB_OUTPUT}"

        # SBOM path
        echo "sbom-path=${{ inputs.image-name }}-sbom.spdx.json" >> "${GITHUB_OUTPUT}"

        # Scan result
        SCAN_PASSED="true"
        if [[ "${{ steps.scan-sbom.outcome }}" == "failure" ]] || [[ "${{ steps.image-scan.outcome }}" == "failure" ]]; then
          SCAN_PASSED="false"
        fi
        echo "scan-passed=${SCAN_PASSED}" >> "${GITHUB_OUTPUT}"

        # Image reference
        echo "image-ref=${IMAGE_REF:-}:${VERSION_TAG:-}" >> "${GITHUB_OUTPUT}"
